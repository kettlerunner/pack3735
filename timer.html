<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Interval Timer - Pack 3735</title>
  <meta name="description" content="Custom interval timer with large, easy-to-read controls for quick workouts." />
  <link rel="stylesheet" href="/css/styles.css" />
  <style>
    body{background:var(--bg);}
    .timer-app{max-width:520px;margin:0 auto;padding:24px 16px 64px;display:flex;flex-direction:column;gap:24px}
    .timer-display{display:flex;flex-direction:column;gap:16px;text-align:center}
    .timer-display .phase{font-size:22px;font-weight:600;text-transform:uppercase;letter-spacing:1px;color:var(--blue)}
    .timer-display .clock{font-size:clamp(56px, 20vw, 96px);line-height:1;font-weight:700;letter-spacing:2px}
    @media (min-width: 480px){.timer-display .clock{font-size:96px}}
    .timeline{height:14px;background:var(--border);border-radius:999px;overflow:hidden}
    .timeline .fill{height:100%;width:0;background:var(--gold);transition:width .15s ease}
    .timer-meta{display:grid;grid-template-columns:repeat(3,1fr);gap:12px;font-size:16px}
    .timer-meta span{display:block}
    .timer-meta .label{font-size:13px;text-transform:uppercase;letter-spacing:.08em;color:var(--ink-2)}
    .timer-controls h1{margin:0;font-size:28px;text-align:center}
    .timer-controls p{margin:0 0 12px;color:var(--ink-2);text-align:center}
    .input-grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .input-grid label{display:flex;flex-direction:column;gap:6px;font-weight:600;font-size:16px}
    .input-grid input{font-size:20px;padding:12px 14px;border-radius:14px;border:1px solid var(--border);background:#fff;appearance:textfield}
    .input-grid input::-webkit-outer-spin-button,
    .input-grid input::-webkit-inner-spin-button{margin:0;-webkit-appearance:none}
    .sound-toggle{display:flex;align-items:center;gap:10px;font-size:16px;margin-top:8px}
    .timer-buttons{display:grid;grid-template-columns:repeat(2,1fr);gap:12px;margin-top:16px}
    .timer-buttons button{font-size:18px;padding:16px 12px;border-radius:16px;font-weight:600;cursor:pointer}
    .timer-buttons button:disabled{opacity:.5;cursor:not-allowed}
    .error{color:#b91c1c;margin-top:8px;min-height:20px;font-weight:600}
    .step-list{margin:12px 0 0;padding:0;list-style:none;font-size:15px;color:var(--ink-2);display:grid;gap:6px}
    .step-list li{display:flex;justify-content:space-between;padding:10px 12px;border:1px solid var(--border);border-radius:12px;background:#fff}
    .step-list .active{color:var(--blue);font-weight:700}
    .notice{font-size:14px;color:var(--ink-2);text-align:center}
    @media (max-width: 480px){
      .timer-app{padding:16px 12px 48px}
      .timer-display.padded,
      .timer-controls.padded{padding:20px 16px}
      .timer-meta{grid-template-columns:1fr;gap:8px;text-align:left}
      .timer-meta div{display:flex;justify-content:space-between;align-items:center}
      .input-grid{grid-template-columns:1fr}
      .timer-buttons{grid-template-columns:1fr}
      .sound-toggle{align-items:flex-start}
    }
  </style>
</head>
<body>
  <main class="timer-app" id="main">
    <section class="timer-display card padded" aria-live="polite">
      <div class="phase" id="phaseLabel">Ready</div>
      <div class="clock" id="clock">00:00</div>
      <div class="timeline" aria-hidden="true">
        <div class="fill" id="progress"></div>
      </div>
      <div class="timer-meta" role="presentation">
        <div>
          <span class="label">Round</span>
          <span id="roundLabel">0 / 0</span>
        </div>
        <div>
          <span class="label">Elapsed</span>
          <span id="elapsed">00:00</span>
        </div>
        <div>
          <span class="label">Remaining</span>
          <span id="remaining">00:00</span>
        </div>
      </div>
    </section>

    <section class="timer-controls card padded" aria-labelledby="timerTitle">
      <h1 id="timerTitle">Interval Timer</h1>
      <p class="notice">Set your work and rest time, then hit start. Big numbers stay visible from a few feet away.</p>
      <div class="input-grid">
        <label for="work">Work (sec)
          <input type="number" id="work" min="5" step="5" value="30" inputmode="numeric" />
        </label>
        <label for="rest">Rest (sec)
          <input type="number" id="rest" min="0" step="5" value="20" inputmode="numeric" />
        </label>
        <label for="buffer">Prep (sec)
          <input type="number" id="buffer" min="0" step="5" value="5" inputmode="numeric" />
        </label>
        <label for="repeats">Rounds
          <input type="number" id="repeats" min="1" step="1" value="5" inputmode="numeric" />
        </label>
      </div>
      <label class="sound-toggle" for="soundToggle">
        <input type="checkbox" id="soundToggle" checked />
        Sound cues on 3-2-1
      </label>
      <div class="timer-buttons">
        <button class="btn btn-primary" id="startStop">Start</button>
        <button class="btn btn-outline" id="reset">Reset</button>
        <button class="btn btn-outline" id="back">Back</button>
        <button class="btn btn-outline" id="skip">Skip</button>
      </div>
      <div class="error" id="error" role="alert"></div>
      <ul class="step-list" id="stepList" aria-live="polite" aria-label="Upcoming intervals"></ul>
    </section>
  </main>

  <script>
  (function(){
    const els = {
      clock: document.getElementById('clock'),
      phase: document.getElementById('phaseLabel'),
      progress: document.getElementById('progress'),
      round: document.getElementById('roundLabel'),
      elapsed: document.getElementById('elapsed'),
      remaining: document.getElementById('remaining'),
      work: document.getElementById('work'),
      rest: document.getElementById('rest'),
      buffer: document.getElementById('buffer'),
      repeats: document.getElementById('repeats'),
      soundToggle: document.getElementById('soundToggle'),
      startStop: document.getElementById('startStop'),
      reset: document.getElementById('reset'),
      skip: document.getElementById('skip'),
      back: document.getElementById('back'),
      error: document.getElementById('error'),
      stepList: document.getElementById('stepList')
    };

    const STORAGE_KEY = 'pack3735_timer_v1';
    let timer = null;

    const state = {
      playing: false,
      schedule: [],
      scheduleIdx: 0,
      startTs: null,
      endTs: null,
      stepRemaining: null,
      totalPlanMs: 0,
      reps: 0
    };

    function fmt(ms){
      if (ms <= 0) return '00:00';
      const totalSeconds = Math.ceil(ms / 1000);
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      return `${String(minutes).padStart(2,'0')}:${String(seconds).padStart(2,'0')}`;
    }

    function beep(freq, duration){
      if (!els.soundToggle.checked) return;
      try {
        const ctx = beep._ctx || (beep._ctx = new (window.AudioContext || window.webkitAudioContext)());
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'sine';
        osc.frequency.value = freq;
        gain.gain.setValueAtTime(0.001, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.2, ctx.currentTime + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration/1000);
        osc.connect(gain).connect(ctx.destination);
        osc.start();
        osc.stop(ctx.currentTime + duration/1000);
      } catch(err) {
        /* ignore */
      }
    }

    function loadSettings(){
      try{
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return;
        const saved = JSON.parse(raw);
        ['work','rest','buffer','repeats'].forEach(key => {
          if (typeof saved[key] === 'number' && !Number.isNaN(saved[key])){
            els[key].value = saved[key];
          }
        });
        if (typeof saved.sound === 'boolean'){
          els.soundToggle.checked = saved.sound;
        }
      }catch(err){ /* ignore */ }
    }

    function saveSettings(){
      const payload = {
        work: Number(els.work.value) || 0,
        rest: Number(els.rest.value) || 0,
        buffer: Number(els.buffer.value) || 0,
        repeats: Number(els.repeats.value) || 0,
        sound: els.soundToggle.checked
      };
      try{
        localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
      }catch(err){ /* ignore */ }
    }

    function buildSchedule(){
      const workSec = Number(els.work.value);
      const restSec = Number(els.rest.value);
      const prepSec = Number(els.buffer.value);
      const rounds = Number(els.repeats.value);
      if ([workSec, restSec, prepSec, rounds].some(v => Number.isNaN(v) || v < 0)){
        els.error.textContent = 'Use whole numbers only.';
        return null;
      }
      if (!rounds){
        els.error.textContent = 'Add at least one round.';
        return null;
      }
      if (workSec <= 0){
        els.error.textContent = 'Work time must be greater than zero.';
        return null;
      }

      const schedule = [];
      if (prepSec > 0){
        schedule.push({ label: 'Get Ready', kind: 'prep', duration: prepSec * 1000, round: 0 });
      }
      for (let i = 0; i < rounds; i++){
        schedule.push({ label: `Work ${i+1}`, kind: 'work', duration: workSec * 1000, round: i+1 });
        if (restSec > 0 && i !== rounds - 1){
          schedule.push({ label: 'Rest', kind: 'rest', duration: restSec * 1000, round: i+1 });
        }
      }
      const totalPlan = schedule.reduce((sum, step) => sum + step.duration, 0);
      return { schedule, total: totalPlan, rounds };
    }

    function renderStepList(){
      els.stepList.innerHTML = '';
      state.schedule.forEach((step, idx) => {
        const li = document.createElement('li');
        const active = idx === state.scheduleIdx;
        if (active){
          li.setAttribute('aria-current', 'step');
        }
        li.innerHTML = `<span class="${active ? 'active' : ''}">${step.label}</span><span>${fmt(step.duration)}</span>`;
        els.stepList.appendChild(li);
      });
    }

    function updateRoundLabel(){
      const current = state.schedule[state.scheduleIdx];
      const round = current && current.round ? current.round : 0;
      els.round.textContent = `${Math.min(round, state.reps)} / ${state.reps}`;
    }

    function updateTitle(){
      if (!state.playing){
        document.title = 'Interval Timer - Pack 3735';
        return;
      }
      const remaining = Math.max(0, state.endTs - performance.now());
      document.title = `${fmt(remaining)} â€¢ ${state.schedule[state.scheduleIdx]?.label || 'Done'}`;
    }

    function computeTotals(){
      if (!state.schedule.length){
        els.elapsed.textContent = '00:00';
        els.remaining.textContent = '00:00';
        return;
      }
      const now = performance.now();
      const completedMs = state.schedule.slice(0, state.scheduleIdx).reduce((sum, step) => sum + step.duration, 0);
      const currentStep = state.schedule[state.scheduleIdx];
      const remainingInStep = currentStep ? (state.stepRemaining ?? currentStep.duration) : 0;
      const elapsed = completedMs + (currentStep ? currentStep.duration - remainingInStep : 0);
      const totalRemaining = Math.max(0, state.totalPlanMs - elapsed);
      els.elapsed.textContent = fmt(elapsed);
      els.remaining.textContent = fmt(totalRemaining);
    }

    function updatePhase(step){
      if (!step){
        els.phase.textContent = 'Done';
        els.clock.textContent = '00:00';
        els.progress.style.width = '100%';
        els.round.textContent = `${state.reps} / ${state.reps}`;
        return;
      }
      const remaining = state.stepRemaining ?? step.duration;
      els.phase.textContent = step.label;
      els.clock.textContent = fmt(remaining);
      els.progress.style.width = '0%';
      updateRoundLabel();
    }

    function startStep(){
      const step = state.schedule[state.scheduleIdx];
      if (!step){
        finishAll();
        return;
      }
      state.stepRemaining = state.stepRemaining ?? step.duration;
      state.startTs = performance.now();
      state.endTs = state.startTs + state.stepRemaining;
      updatePhase(step);
    }

    function finishAll(){
      state.playing = false;
      cancelAnimationFrame(timer);
      timer = null;
      state.scheduleIdx = state.schedule.length;
      state.stepRemaining = null;
      els.startStop.textContent = 'Start';
      els.phase.textContent = 'Done';
      els.clock.textContent = '00:00';
      els.progress.style.width = '100%';
      els.round.textContent = `${state.reps} / ${state.reps}`;
      document.title = 'Interval Timer - Pack 3735';
      renderStepList();
      computeTotals();
    }

    function tick(){
      if (!state.playing){
        cancelAnimationFrame(timer);
        timer = null;
        return;
      }
      const now = performance.now();
      const step = state.schedule[state.scheduleIdx];
      if (!step){
        finishAll();
        return;
      }
      const remaining = Math.max(0, state.endTs - now);
      state.stepRemaining = remaining;
      els.clock.textContent = fmt(remaining);
      const pct = 1 - (remaining / step.duration);
      els.progress.style.width = `${Math.min(100, Math.max(0, pct * 100)).toFixed(1)}%`;

      // cues
      const secsLeft = Math.ceil(remaining / 1000);
      if ([3,2,1].includes(secsLeft)){
        if (tick._lastCue !== secsLeft){
          tick._lastCue = secsLeft;
          beep(760 + (3 - secsLeft) * 120, 90);
        }
      } else if (secsLeft > 3) {
        tick._lastCue = null;
      }

      if (remaining <= 0){
        state.scheduleIdx += 1;
        state.stepRemaining = null;
        if (state.scheduleIdx >= state.schedule.length){
          finishAll();
          return;
        }
        renderStepList();
        startStep();
        tick._lastCue = null;
        return;
      }

      updateTitle();
      computeTotals();
      timer = requestAnimationFrame(tick);
    }

    function startTimer(){
      if (!state.schedule.length){
        const plan = buildSchedule();
        if (!plan) return;
        state.schedule = plan.schedule;
        state.totalPlanMs = plan.total;
        state.reps = plan.rounds;
        state.scheduleIdx = 0;
        state.stepRemaining = null;
        renderStepList();
        startStep();
      }
      const current = state.schedule[state.scheduleIdx];
      if (!current){
        finishAll();
        return;
      }
      if (state.stepRemaining == null){
        state.stepRemaining = current.duration;
      }
      state.playing = true;
      els.startStop.textContent = 'Pause';
      state.startTs = performance.now();
      state.endTs = state.startTs + state.stepRemaining;
      timer = requestAnimationFrame(tick);
      updateTitle();
    }

    function pauseTimer(){
      state.playing = false;
      cancelAnimationFrame(timer);
      timer = null;
      if (state.endTs){
        const remaining = Math.max(0, state.endTs - performance.now());
        state.stepRemaining = remaining;
        els.clock.textContent = fmt(remaining);
      }
      els.startStop.textContent = 'Resume';
      document.title = 'Interval Timer - Pack 3735';
    }

    function gotoStep(idx){
      if (!state.schedule.length) return;
      if (idx >= state.schedule.length){
        finishAll();
        return;
      }
      state.scheduleIdx = Math.max(0, Math.min(idx, state.schedule.length - 1));
      const current = state.schedule[state.scheduleIdx];
      state.stepRemaining = current ? current.duration : null;
      tick._lastCue = null;
      startStep();
      renderStepList();
      computeTotals();
      if (!state.playing){
        els.clock.textContent = current ? fmt(current.duration) : '00:00';
      }
    }

    function resetAll(clearSchedule = true){
      cancelAnimationFrame(timer);
      timer = null;
      state.playing = false;
      state.scheduleIdx = 0;
      state.startTs = null;
      state.endTs = null;
      state.stepRemaining = null;
      state.reps = 0;
      state.totalPlanMs = 0;
      if (clearSchedule) state.schedule = [];
      els.phase.textContent = 'Ready';
      els.clock.textContent = '00:00';
      els.progress.style.width = '0%';
      els.round.textContent = '0 / 0';
      els.elapsed.textContent = '00:00';
      els.remaining.textContent = '00:00';
      els.error.textContent = '';
      els.stepList.innerHTML = '';
      els.startStop.textContent = 'Start';
      document.title = 'Interval Timer - Pack 3735';
      tick._lastCue = null;
    }

    // Event wiring
    ['work','rest','buffer','repeats'].forEach(id => {
      els[id].addEventListener('change', () => {
        saveSettings();
        els.error.textContent = '';
        resetAll();
      });
      els[id].addEventListener('input', () => {
        els.error.textContent = '';
      });
      els[id].addEventListener('blur', saveSettings);
    });
    els.soundToggle.addEventListener('change', saveSettings);

    els.startStop.addEventListener('click', () => {
      if (!state.playing){
        if (!state.schedule.length || state.scheduleIdx >= state.schedule.length){
          resetAll();
        }
        startTimer();
      } else {
        pauseTimer();
      }
    });

    els.reset.addEventListener('click', () => {
      resetAll();
      saveSettings();
    });

    els.skip.addEventListener('click', () => {
      if (!state.schedule.length) return;
      gotoStep(state.scheduleIdx + 1);
      if (!state.playing){
        els.startStop.textContent = 'Resume';
      }
    });

    els.back.addEventListener('click', () => {
      if (!state.schedule.length) return;
      gotoStep(state.scheduleIdx - 1);
      if (!state.playing){
        els.startStop.textContent = 'Resume';
      }
    });

    window.addEventListener('keydown', (e) => {
      if (['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) return;
      if (e.code === 'Space'){ e.preventDefault(); els.startStop.click(); }
      if (e.key === 'r' || e.key === 'R'){ e.preventDefault(); els.reset.click(); }
      if (e.key === 'n' || e.key === 'N'){ e.preventDefault(); els.skip.click(); }
      if (e.key === 'b' || e.key === 'B'){ e.preventDefault(); els.back.click(); }
    });

    loadSettings();
    resetAll();
    setInterval(computeTotals, 200);
  })();
  </script>
</body>
</html>
