<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Interval Timer - Pack 3735</title>
  <meta name="description" content="Custom interval timer with large, easy-to-read controls for quick workouts." />
  <meta name="robots" content="noindex, nofollow" />
  <link rel="stylesheet" href="/css/styles.css" />
  <style>
    :root{color-scheme: light;}
    body{
      background:var(--page-bg);
      color:var(--page-ink);
      --page-bg:var(--bg);
      --page-ink:var(--ink);
      --muted:var(--ink-2);
      --card-bg:#fff;
      --card-border:var(--border);
      --input-bg:#fff;
      --input-border:var(--border);
      transition:background .3s ease,color .3s ease;
    }
    body[data-theme="dark"]{
      color-scheme:dark;
      --page-bg:#0b1220;
      --page-ink:#f8fafc;
      --muted:#cbd5f5;
      --card-bg:rgba(15,23,42,.85);
      --card-border:rgba(148,163,184,.35);
      --input-bg:rgba(15,23,42,.95);
      --input-border:rgba(148,163,184,.6);
    }
    .timer-app{max-width:520px;margin:0 auto;padding:24px 16px 64px;display:flex;flex-direction:column;gap:24px;color:var(--page-ink)}
    .timer-app .card{background:var(--card-bg);border-color:var(--card-border);color:var(--page-ink);}
    .timer-display{display:flex;flex-direction:column;gap:16px;text-align:center;position:relative;overflow:hidden;isolation:isolate;--step-progress:0}
    .timer-display::before{content:"";position:absolute;inset:0;background:linear-gradient(120deg,rgba(15,157,88,.3) 0%,rgba(251,188,4,.36) 50%,rgba(234,67,53,.42) 100%);transform-origin:left;transform:scaleX(var(--step-progress));transition:transform .4s ease,opacity .4s ease;border-radius:inherit;pointer-events:none;opacity:calc(.12 + (var(--step-progress) * .6))}
    .timer-display > *{position:relative;z-index:1}
    .timer-display .phase{font-size:22px;font-weight:600;text-transform:uppercase;letter-spacing:1px;color:var(--blue)}
    .timer-display .clock{font-size:clamp(56px, 20vw, 96px);line-height:1;font-weight:700;letter-spacing:2px}
    @media (min-width: 480px){.timer-display .clock{font-size:96px}}
    .timeline{height:14px;background:var(--card-border);border-radius:999px;overflow:hidden}
    .timeline .fill{height:100%;width:0;background:var(--gold);transition:width .15s ease}
    .timer-meta{display:grid;grid-template-columns:repeat(3,1fr);gap:12px;font-size:16px}
    .timer-meta span{display:block}
    .timer-meta .label{font-size:13px;text-transform:uppercase;letter-spacing:.08em;color:var(--muted)}
    .timer-controls h1{margin:0;font-size:28px;text-align:center}
    .timer-controls p{margin:0 0 12px;color:var(--muted);text-align:center}
    .input-grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .input-grid label{display:flex;flex-direction:column;gap:6px;font-weight:600;font-size:16px}
    .input-grid input{font-size:20px;padding:12px 14px;border-radius:14px;border:1px solid var(--input-border);background:var(--input-bg);color:var(--page-ink);appearance:textfield}
    .input-grid input::-webkit-outer-spin-button,
    .input-grid input::-webkit-inner-spin-button{margin:0;-webkit-appearance:none}
    .sound-toggle{display:flex;align-items:center;gap:10px;font-size:16px;margin-top:8px;color:var(--muted)}
    .timer-buttons{display:grid;grid-template-columns:repeat(2,1fr);gap:12px;margin-top:16px}
    .timer-buttons button{font-size:18px;padding:16px 12px;border-radius:16px;font-weight:600;cursor:pointer}
    .timer-buttons button:disabled{opacity:.5;cursor:not-allowed}
    .error{color:#b91c1c;margin-top:8px;min-height:20px;font-weight:600}
    .step-list{margin:12px 0 0;padding:0;list-style:none;font-size:15px;color:var(--muted);display:grid;gap:6px}
    .step-list li{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border:1px solid var(--card-border);border-radius:12px;background:var(--card-bg);position:relative;overflow:hidden;--step-progress:0;transition:border-color .3s ease,box-shadow .3s ease}
    .step-list li::before{content:"";position:absolute;inset:0;background:linear-gradient(120deg,rgba(15,157,88,.3) 0%,rgba(251,188,4,.36) 50%,rgba(234,67,53,.42) 100%);transform-origin:left;transform:scaleX(var(--step-progress));transition:transform .4s ease,opacity .4s ease;border-radius:inherit;pointer-events:none;opacity:0}
    .step-list li.is-active{border-color:var(--blue);box-shadow:0 0 0 1px rgba(0,63,135,.2)}
    .step-list li.is-active::before,.step-list li.is-complete::before{opacity:.22}
    .step-list li.is-complete{border-color:var(--pale)}
    .step-list li > *{position:relative;z-index:1}
    .step-list .step-label{font-weight:600}
    .step-list .step-label.active{color:var(--blue)}
    .step-list .step-time{font-variant-numeric:tabular-nums;font-weight:600}
    .notice{font-size:14px;color:var(--muted);text-align:center}
    @keyframes slideInUp{0%{transform:translateY(16px);opacity:0}100%{transform:translateY(0);opacity:1}}
    .timer-display .phase.is-animating,.timer-display .clock.is-animating{animation:slideInUp .45s cubic-bezier(.22,.61,.36,1) both}
    @media (prefers-reduced-motion: reduce){
      .timer-display::before{transition:none}
      .timer-display .phase.is-animating,.timer-display .clock.is-animating{animation:none}
      .step-list li::before{transition:none}
    }
    @media (min-width: 960px){
      .timer-app{max-width:1040px;padding:32px 24px 80px;display:grid;grid-template-columns:minmax(320px,1fr) minmax(360px,1fr);gap:32px;align-items:flex-start}
      .timer-display,.timer-controls{height:100%}
      .timer-display{position:sticky;top:32px}
      .timer-meta{grid-template-columns:repeat(3,minmax(0,1fr));text-align:left}
      .timer-buttons{grid-template-columns:repeat(2,minmax(0,1fr))}
    }

    @media (max-width: 480px){
      .timer-app{padding:16px 12px 48px}
      .timer-display.padded,
      .timer-controls.padded{padding:20px 16px}
      .timer-meta{grid-template-columns:1fr;gap:8px;text-align:left}
      .timer-meta div{display:flex;justify-content:space-between;align-items:center}
      .input-grid{grid-template-columns:1fr}
      .timer-buttons{grid-template-columns:1fr}
      .sound-toggle{align-items:flex-start}
    }
    .controls-head{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
    .controls-head h1{text-align:left}
    .theme-toggle{display:inline-flex;align-items:center;gap:8px;font-size:15px;font-weight:600;padding:10px 14px;border-radius:999px;border:1px solid var(--card-border);background:var(--card-bg);color:var(--page-ink);cursor:pointer;transition:background .3s ease,color .3s ease,border-color .3s ease}
    .theme-toggle__icon{font-size:18px;line-height:1}
    .theme-toggle:hover{background:rgba(252,209,22,.12)}
    body[data-theme="dark"] .timer-display .phase{color:var(--gold)}
    body[data-theme="dark"] .timer-app .card{box-shadow:0 24px 48px rgba(8,47,73,.45)}
    body[data-theme="dark"] .step-list li.is-active{box-shadow:0 0 0 1px rgba(148,163,184,.4)}
    body[data-theme="dark"] .step-list li.is-complete{border-color:rgba(148,163,184,.35)}
    body[data-theme="dark"] .timeline{background:rgba(148,163,184,.3)}
    body[data-theme="dark"] .sound-toggle{color:var(--muted)}
    body[data-theme="dark"] .theme-toggle{background:rgba(15,23,42,.6);border-color:rgba(148,163,184,.5)}
    body[data-theme="dark"] .theme-toggle:hover{background:rgba(148,163,184,.2)}
    body[data-theme="dark"] .btn-outline{border-color:var(--card-border);background:rgba(148,163,184,.12);color:var(--page-ink)}
    body[data-theme="dark"] .btn-outline:hover{background:rgba(148,163,184,.18)}
    body[data-theme="dark"] .step-list{color:var(--muted)}
    body[data-theme="dark"] .notice{color:var(--muted)}
    body[data-theme="dark"] .input-grid input{border-color:var(--input-border);background:var(--input-bg);color:var(--page-ink)}
  </style>
</head>
<body>
  <main class="timer-app" id="main">
    <section class="timer-display card padded" aria-live="polite">
      <div class="phase" id="phaseLabel">Ready</div>
      <div class="clock" id="clock">00:00</div>
      <div class="timeline" aria-hidden="true">
        <div class="fill" id="progress"></div>
      </div>
      <div class="timer-meta" role="presentation">
        <div>
          <span class="label">Round</span>
          <span id="roundLabel">0 / 0</span>
        </div>
        <div>
          <span class="label">Elapsed</span>
          <span id="elapsed">00:00</span>
        </div>
        <div>
          <span class="label">Remaining</span>
          <span id="remaining">00:00</span>
        </div>
      </div>
    </section>

    <section class="timer-controls card padded" aria-labelledby="timerTitle">
      <div class="controls-head">
        <h1 id="timerTitle">Interval Timer</h1>
        <button type="button" class="theme-toggle" id="themeToggle" aria-pressed="false">
          <span class="theme-toggle__icon" aria-hidden="true">ðŸŒ™</span>
          <span class="theme-toggle__text">Switch to dark mode</span>
        </button>
      </div>
      <p class="notice">Set your work and rest time, then hit start. Big numbers stay visible from a few feet away.</p>
      <div class="input-grid">
        <label for="work">Work (sec)
          <input type="number" id="work" min="5" step="5" value="30" inputmode="numeric" />
        </label>
        <label for="rest">Rest (sec)
          <input type="number" id="rest" min="0" step="5" value="20" inputmode="numeric" />
        </label>
        <label for="buffer">Prep (sec)
          <input type="number" id="buffer" min="0" step="5" value="5" inputmode="numeric" />
        </label>
        <label for="repeats">Rounds
          <input type="number" id="repeats" min="1" step="1" value="5" inputmode="numeric" />
        </label>
      </div>
      <label class="sound-toggle" for="soundToggle">
        <input type="checkbox" id="soundToggle" checked />
        Sound cues on 3-2-1
      </label>
      <div class="timer-buttons">
        <button class="btn btn-primary" id="startStop">Start</button>
        <button class="btn btn-outline" id="reset">Reset</button>
        <button class="btn btn-outline" id="back">Back</button>
        <button class="btn btn-outline" id="skip">Skip</button>
      </div>
      <div class="error" id="error" role="alert"></div>
      <ul class="step-list" id="stepList" aria-live="polite" aria-label="Upcoming intervals"></ul>
    </section>
  </main>

  <script>
  (function(){
    const els = {
      clock: document.getElementById('clock'),
      phase: document.getElementById('phaseLabel'),
      progress: document.getElementById('progress'),
      round: document.getElementById('roundLabel'),
      elapsed: document.getElementById('elapsed'),
      remaining: document.getElementById('remaining'),
      work: document.getElementById('work'),
      rest: document.getElementById('rest'),
      buffer: document.getElementById('buffer'),
      repeats: document.getElementById('repeats'),
      soundToggle: document.getElementById('soundToggle'),
      themeToggle: document.getElementById('themeToggle'),
      startStop: document.getElementById('startStop'),
      reset: document.getElementById('reset'),
      skip: document.getElementById('skip'),
      back: document.getElementById('back'),
      error: document.getElementById('error'),
      stepList: document.getElementById('stepList'),
      display: document.querySelector('.timer-display')
    };

    const STORAGE_KEY = 'pack3735_timer_v1';
    let timer = null;

    const state = {
      playing: false,
      schedule: [],
      scheduleIdx: 0,
      startTs: null,
      endTs: null,
      stepRemaining: null,
      totalPlanMs: 0,
      reps: 0
    };

    const prefersReducedMotion = !!(window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches);
    const prefersDark = !!(window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches);
    let audioCtx = null;

    function setStepProgress(value){
      if (!els.display) return;
      const clamped = Math.max(0, Math.min(1, value));
      els.display.style.setProperty('--step-progress', String(clamped));
    }

    function ensureAudioContext(){
      const AudioContextCtor = window.AudioContext || window.webkitAudioContext;
      if (!AudioContextCtor) return null;
      if (!audioCtx){
        try {
          audioCtx = new AudioContextCtor();
        } catch(err){
          return null;
        }
      }
      if (audioCtx && audioCtx.state === 'suspended'){
        audioCtx.resume().catch(() => {});
      }
      return audioCtx;
    }

    function unlockAudio(){
      if (unlockAudio._unlocked) return;
      const ctx = ensureAudioContext();
      if (!ctx) return;
      try {
        const buffer = ctx.createBuffer(1, 1, 22050);
        const source = ctx.createBufferSource();
        source.buffer = buffer;
        source.connect(ctx.destination);
        if (ctx.state === 'suspended'){
          ctx.resume().catch(() => {});
        }
        source.start();
        unlockAudio._unlocked = true;
      } catch(err){
        /* ignore */
      }
    }

    function beep(freq, duration){
      if (!els.soundToggle.checked) return;
      const ctx = ensureAudioContext();
      if (!ctx) return;
      try {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        const now = ctx.currentTime;
        osc.type = 'sine';
        osc.frequency.setValueAtTime(freq, now);
        gain.gain.setValueAtTime(0.001, now);
        gain.gain.exponentialRampToValueAtTime(0.2, now + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.001, now + duration/1000);
        osc.connect(gain).connect(ctx.destination);
        osc.start(now);
        osc.stop(now + duration/1000);
      } catch(err){
        /* ignore */
      }
    }

    function celebrate(){
      if (!els.soundToggle.checked) return;
      const ctx = ensureAudioContext();
      if (!ctx) return;
      const notes = [523.25, 659.25, 783.99];
      const now = ctx.currentTime;
      notes.forEach((freq, idx) => {
        try {
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          const startAt = now + idx * 0.08;
          const endAt = startAt + 0.55;
          osc.type = 'triangle';
          osc.frequency.setValueAtTime(freq, startAt);
          gain.gain.setValueAtTime(0.001, startAt);
          gain.gain.exponentialRampToValueAtTime(0.25, startAt + 0.06);
          gain.gain.exponentialRampToValueAtTime(0.001, endAt);
          osc.connect(gain).connect(ctx.destination);
          osc.start(startAt);
          osc.stop(endAt);
        } catch(err){
          /* ignore */
        }
      });
    }

    function animatePhase(){
      ['phase', 'clock'].forEach(key => {
        const target = els[key];
        if (!target) return;
        target.classList.remove('is-animating');
        void target.offsetWidth;
        if (!prefersReducedMotion){
          target.classList.add('is-animating');
        }
      });
    }

    function scrollToTop(){
      if (typeof window.scrollTo !== 'function') return;
      try {
        window.scrollTo({ top: 0, behavior: prefersReducedMotion ? 'auto' : 'smooth' });
      } catch(err){
        window.scrollTo(0, 0);
      }
    }

    function fmt(ms){
      if (ms <= 0) return '00:00';
      const totalSeconds = Math.ceil(ms / 1000);
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      return `${String(minutes).padStart(2,'0')}:${String(seconds).padStart(2,'0')}`;
    }

    function loadSettings(){
      try{
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return;
        const saved = JSON.parse(raw);
        ['work','rest','buffer','repeats'].forEach(key => {
          if (typeof saved[key] === 'number' && !Number.isNaN(saved[key])){
            els[key].value = saved[key];
          }
        });
        if (typeof saved.sound === 'boolean'){
          els.soundToggle.checked = saved.sound;
        }
        if (typeof saved.theme === 'string'){
          applyTheme(saved.theme);
        }
      }catch(err){ /* ignore */ }
      if (!document.body.dataset.theme){
        applyTheme(prefersDark ? 'dark' : 'light');
      }
    }

    function saveSettings(){
      const payload = {
        work: Number(els.work.value) || 0,
        rest: Number(els.rest.value) || 0,
        buffer: Number(els.buffer.value) || 0,
        repeats: Number(els.repeats.value) || 0,
        sound: els.soundToggle.checked,
        theme: document.body.dataset.theme === 'dark' ? 'dark' : 'light'
      };
      try{
        localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
      }catch(err){ /* ignore */ }
    }

    function updateThemeToggle(mode){
      if (!els.themeToggle) return;
      const normalized = mode === 'dark' ? 'dark' : 'light';
      const icon = els.themeToggle.querySelector('.theme-toggle__icon');
      const text = els.themeToggle.querySelector('.theme-toggle__text');
      els.themeToggle.setAttribute('aria-pressed', normalized === 'dark' ? 'true' : 'false');
      if (icon){
        icon.textContent = normalized === 'dark' ? 'ðŸŒž' : 'ðŸŒ™';
      }
      if (text){
        text.textContent = normalized === 'dark' ? 'Switch to light mode' : 'Switch to dark mode';
      }
    }

    function applyTheme(mode){
      const normalized = mode === 'dark' ? 'dark' : 'light';
      document.body.dataset.theme = normalized;
      document.documentElement.style.setProperty('color-scheme', normalized);
      updateThemeToggle(normalized);
    }

    function buildSchedule(){
      const workSec = Number(els.work.value);
      const restSec = Number(els.rest.value);
      const prepSec = Number(els.buffer.value);
      const rounds = Number(els.repeats.value);
      if ([workSec, restSec, prepSec, rounds].some(v => Number.isNaN(v) || v < 0)){
        els.error.textContent = 'Use whole numbers only.';
        return null;
      }
      if (!rounds){
        els.error.textContent = 'Add at least one round.';
        return null;
      }
      if (workSec <= 0){
        els.error.textContent = 'Work time must be greater than zero.';
        return null;
      }

      const schedule = [];
      if (prepSec > 0){
        schedule.push({ label: 'Get Ready', kind: 'prep', duration: prepSec * 1000, round: 0 });
      }
      for (let i = 0; i < rounds; i++){
        schedule.push({ label: `Work ${i+1}`, kind: 'work', duration: workSec * 1000, round: i+1 });
        if (restSec > 0 && i !== rounds - 1){
          schedule.push({ label: 'Rest', kind: 'rest', duration: restSec * 1000, round: i+1 });
        }
      }
      const totalPlan = schedule.reduce((sum, step) => sum + step.duration, 0);
      return { schedule, total: totalPlan, rounds };
    }

    function renderStepList(){
      els.stepList.innerHTML = '';
      state.schedule.forEach((step, idx) => {
        const li = document.createElement('li');
        li.dataset.index = String(idx);
        const label = document.createElement('span');
        label.className = 'step-label';
        label.textContent = step.label;
        const time = document.createElement('span');
        time.className = 'step-time';
        time.dataset.duration = String(step.duration);
        time.textContent = fmt(step.duration);
        li.append(label, time);
        els.stepList.appendChild(li);
      });
      syncStepListState();
    }

    function syncStepListState(){
      if (!els.stepList.children.length) return;
      Array.from(els.stepList.children).forEach((li) => {
        const idx = Number(li.dataset.index);
        const step = state.schedule[idx];
        const label = li.querySelector('.step-label');
        const time = li.querySelector('.step-time');
        const isCurrent = idx === state.scheduleIdx && idx < state.schedule.length;
        const isComplete = idx < state.scheduleIdx || (!step && idx < state.schedule.length);
        if (isCurrent){
          li.setAttribute('aria-current', 'step');
        } else {
          li.removeAttribute('aria-current');
        }
        li.classList.toggle('is-active', isCurrent);
        li.classList.toggle('is-complete', isComplete);
        if (label){
          label.classList.toggle('active', isCurrent);
        }
        if (time && step){
          time.dataset.duration = String(step.duration);
          if (isComplete){
            time.textContent = 'Done';
          } else if (isCurrent){
            const remaining = state.stepRemaining == null ? step.duration : state.stepRemaining;
            time.textContent = fmt(remaining);
          } else {
            time.textContent = fmt(step.duration);
          }
        } else if (time && isComplete){
          time.textContent = 'Done';
        }
        let progressValue = 0;
        if (isComplete){
          progressValue = 1;
        } else if (isCurrent && step){
          const remaining = state.stepRemaining == null ? step.duration : state.stepRemaining;
          progressValue = 1 - (remaining / step.duration);
        }
        li.style.setProperty('--step-progress', String(Math.max(0, Math.min(1, progressValue))));
      });
    }

    function updateActiveStepDisplay(remainingMs, pct){
      const activeItem = els.stepList.querySelector('li.is-active');
      if (!activeItem) return;
      activeItem.style.setProperty('--step-progress', String(Math.max(0, Math.min(1, pct))));
      const time = activeItem.querySelector('.step-time');
      if (time){
        if (remainingMs <= 0){
          time.textContent = 'Done';
        } else {
          time.textContent = fmt(remainingMs);
        }
      }
    }

    function updateRoundLabel(){
      const current = state.schedule[state.scheduleIdx];
      const round = current && current.round ? current.round : 0;
      els.round.textContent = `${Math.min(round, state.reps)} / ${state.reps}`;
    }

    function updateTitle(){
      if (!state.playing){
        document.title = 'Interval Timer - Pack 3735';
        return;
      }
      const remaining = Math.max(0, state.endTs - performance.now());
      document.title = `${fmt(remaining)} â€¢ ${state.schedule[state.scheduleIdx]?.label || 'Done'}`;
    }

    function computeTotals(){
      if (!state.schedule.length){
        els.elapsed.textContent = '00:00';
        els.remaining.textContent = '00:00';
        return;
      }
      const now = performance.now();
      const completedMs = state.schedule.slice(0, state.scheduleIdx).reduce((sum, step) => sum + step.duration, 0);
      const currentStep = state.schedule[state.scheduleIdx];
      const remainingInStep = currentStep ? (state.stepRemaining ?? currentStep.duration) : 0;
      const elapsed = completedMs + (currentStep ? currentStep.duration - remainingInStep : 0);
      const totalRemaining = Math.max(0, state.totalPlanMs - elapsed);
      els.elapsed.textContent = fmt(elapsed);
      els.remaining.textContent = fmt(totalRemaining);
    }

    function updatePhase(step){
      if (!step){
        els.phase.textContent = 'Done';
        els.clock.textContent = '00:00';
        els.progress.style.width = '100%';
        els.round.textContent = `${state.reps} / ${state.reps}`;
        setStepProgress(1);
        syncStepListState();
        animatePhase();
        return;
      }
      const remaining = state.stepRemaining ?? step.duration;
      els.phase.textContent = step.label;
      els.clock.textContent = fmt(remaining);
      els.progress.style.width = '0%';
      updateRoundLabel();
      setStepProgress(0);
      syncStepListState();
      animatePhase();
    }

    function startStep(){
      const step = state.schedule[state.scheduleIdx];
      if (!step){
        finishAll();
        return;
      }
      state.stepRemaining = state.stepRemaining ?? step.duration;
      state.startTs = performance.now();
      state.endTs = state.startTs + state.stepRemaining;
      updatePhase(step);
      const pct = 1 - ((state.stepRemaining ?? step.duration) / step.duration);
      updateActiveStepDisplay(state.stepRemaining ?? step.duration, pct);
    }

    function finishAll(){
      state.playing = false;
      cancelAnimationFrame(timer);
      timer = null;
      state.scheduleIdx = state.schedule.length;
      state.stepRemaining = null;
      els.startStop.textContent = 'Start';
      els.phase.textContent = 'Done';
      els.clock.textContent = '00:00';
      els.progress.style.width = '100%';
      setStepProgress(1);
      els.round.textContent = `${state.reps} / ${state.reps}`;
      animatePhase();
      document.title = 'Interval Timer - Pack 3735';
      renderStepList();
      computeTotals();
      if (state.schedule.length){
        celebrate();
      }
    }

    function tick(){
      if (!state.playing){
        cancelAnimationFrame(timer);
        timer = null;
        return;
      }
      const now = performance.now();
      const step = state.schedule[state.scheduleIdx];
      if (!step){
        finishAll();
        return;
      }
      const remaining = Math.max(0, state.endTs - now);
      state.stepRemaining = remaining;
      els.clock.textContent = fmt(remaining);
      const pct = 1 - (remaining / step.duration);
      els.progress.style.width = `${Math.min(100, Math.max(0, pct * 100)).toFixed(1)}%`;
      setStepProgress(pct);
      updateActiveStepDisplay(remaining, pct);

      // cues
      const secsLeft = Math.ceil(remaining / 1000);
      if ([3,2,1].includes(secsLeft)){
        if (tick._lastCue !== secsLeft){
          tick._lastCue = secsLeft;
          beep(760 + (3 - secsLeft) * 120, 90);
        }
      } else if (secsLeft > 3) {
        tick._lastCue = null;
      }

      if (remaining <= 0){
        setStepProgress(1);
        updateActiveStepDisplay(0, 1);
        state.scheduleIdx += 1;
        state.stepRemaining = null;
        if (state.scheduleIdx >= state.schedule.length){
          finishAll();
          return;
        }
        renderStepList();
        startStep();
        tick._lastCue = null;
        computeTotals();
        updateTitle();
        timer = requestAnimationFrame(tick);
        return;
      }

      updateTitle();
      computeTotals();
      timer = requestAnimationFrame(tick);
    }

    function startTimer(){
      if (!state.schedule.length){
        const plan = buildSchedule();
        if (!plan) return;
        state.schedule = plan.schedule;
        state.totalPlanMs = plan.total;
        state.reps = plan.rounds;
        state.scheduleIdx = 0;
        state.stepRemaining = null;
        renderStepList();
        startStep();
      }
      const current = state.schedule[state.scheduleIdx];
      if (!current){
        finishAll();
        return;
      }
      if (state.stepRemaining == null){
        state.stepRemaining = current.duration;
      }
      state.playing = true;
      els.startStop.textContent = 'Pause';
      state.startTs = performance.now();
      state.endTs = state.startTs + state.stepRemaining;
      timer = requestAnimationFrame(tick);
      updateTitle();
    }

    function pauseTimer(){
      state.playing = false;
      cancelAnimationFrame(timer);
      timer = null;
      if (state.endTs){
        const remaining = Math.max(0, state.endTs - performance.now());
        state.stepRemaining = remaining;
        els.clock.textContent = fmt(remaining);
        const current = state.schedule[state.scheduleIdx];
        if (current){
          const pct = current.duration ? 1 - (remaining / current.duration) : 1;
          updateActiveStepDisplay(remaining, pct);
        }
      }
      els.startStop.textContent = 'Resume';
      document.title = 'Interval Timer - Pack 3735';
    }

    function gotoStep(idx){
      if (!state.schedule.length) return;
      if (idx >= state.schedule.length){
        finishAll();
        return;
      }
      state.scheduleIdx = Math.max(0, Math.min(idx, state.schedule.length - 1));
      const current = state.schedule[state.scheduleIdx];
      state.stepRemaining = current ? current.duration : null;
      tick._lastCue = null;
      startStep();
      renderStepList();
      computeTotals();
      if (!state.playing){
        els.clock.textContent = current ? fmt(current.duration) : '00:00';
        if (current){
          updateActiveStepDisplay(current.duration, 0);
        }
      }
    }

    function resetAll(clearSchedule = true){
      cancelAnimationFrame(timer);
      timer = null;
      state.playing = false;
      state.scheduleIdx = 0;
      state.startTs = null;
      state.endTs = null;
      state.stepRemaining = null;
      state.reps = 0;
      state.totalPlanMs = 0;
      if (clearSchedule) state.schedule = [];
      els.phase.textContent = 'Ready';
      els.clock.textContent = '00:00';
      els.progress.style.width = '0%';
      setStepProgress(0);
      els.round.textContent = '0 / 0';
      els.elapsed.textContent = '00:00';
      els.remaining.textContent = '00:00';
      els.error.textContent = '';
      els.stepList.innerHTML = '';
      els.startStop.textContent = 'Start';
      document.title = 'Interval Timer - Pack 3735';
      tick._lastCue = null;
    }

    // Event wiring
    ['work','rest','buffer','repeats'].forEach(id => {
      els[id].addEventListener('change', () => {
        saveSettings();
        els.error.textContent = '';
        resetAll();
      });
      els[id].addEventListener('input', () => {
        els.error.textContent = '';
      });
      els[id].addEventListener('blur', saveSettings);
    });
    els.soundToggle.addEventListener('change', () => {
      saveSettings();
      if (els.soundToggle.checked){
        unlockAudio();
      }
    });

    els.startStop.addEventListener('click', () => {
      if (!state.playing){
        if (!state.schedule.length || state.scheduleIdx >= state.schedule.length){
          resetAll();
        }
        unlockAudio();
        scrollToTop();
        startTimer();
      } else {
        pauseTimer();
      }
    });

    els.reset.addEventListener('click', () => {
      resetAll();
      saveSettings();
    });

    els.skip.addEventListener('click', () => {
      if (!state.schedule.length) return;
      gotoStep(state.scheduleIdx + 1);
      if (!state.playing){
        els.startStop.textContent = 'Resume';
      }
    });

    els.back.addEventListener('click', () => {
      if (!state.schedule.length) return;
      gotoStep(state.scheduleIdx - 1);
      if (!state.playing){
        els.startStop.textContent = 'Resume';
      }
    });

    window.addEventListener('keydown', (e) => {
      if (['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) return;
      if (e.code === 'Space'){ e.preventDefault(); els.startStop.click(); }
      if (e.key === 'r' || e.key === 'R'){ e.preventDefault(); els.reset.click(); }
      if (e.key === 'n' || e.key === 'N'){ e.preventDefault(); els.skip.click(); }
      if (e.key === 'b' || e.key === 'B'){ e.preventDefault(); els.back.click(); }
    });

    if (els.themeToggle){
      els.themeToggle.addEventListener('click', () => {
        const next = document.body.dataset.theme === 'dark' ? 'light' : 'dark';
        applyTheme(next);
        saveSettings();
      });
    }

    ['mousedown','touchstart'].forEach(evt => {
      document.addEventListener(evt, unlockAudio, { once: true, passive: true });
    });

    loadSettings();
    resetAll();
    setInterval(computeTotals, 200);
  })();
  </script>
</body>
</html>
